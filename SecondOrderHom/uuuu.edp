load "UMFPACK64"
include "../HomogenizedGeometry.idp"
include "../PlotInGMSH.idp"

//plot(Th);

int coil=Th( (PosCoilIn+PosCoilOut)/2,PosCoilIn/4).region;
int lamin=Th( PosCoilIn/2,PosCoilIn/2).region;  
int airIn=Th( PosCoilIn-RadiusCoil/2,PosCoilIn-RadiusCoil/2).region;
int airOut=Th( 1.1*PosCoilOut,1.1*PosCoilOut).region;

int numStages = 5;
real [int] lambda(2*numStages+1);
real RR;
real LL;
real nu0=1e7/4/pi;
real nu1=1e4/4/pi;
real InsRatio = 0.9;
real tgv = 1e30;

func co = 1.0*(region==coil);
func yo = 1.0*(region==lamin);
func ar = 1.0*(region==airIn)+1.0*(region==airOut)+1.0*(region==coil);
func sig=4e7*co;
func sigLam=1e6*(1e-3)^2/12*yo;
func nu=nu0*ar + nu1/InsRatio*yo;

fespace Ph(Th,P1);
Ph u,v;

fespace Eh(Th,RT0Ortho);

fespace Xh(Th,[RT0Ortho,RT0Ortho]);
Xh[int] [A0x,A0y,A2x,A2y](numStages);
Xh[int] [E0x,E0y,E2x,E2y](numStages+1);
Xh[int] [J0x,J0y,J2x,J2y](numStages+1);
Xh [A0sx,A0sy,A2sx,A2sy];
Xh [E0sx,E0sy,E2sx,E2sy];
real[int] Fm(Xh.ndof);

fespace Zh(Th,[P1,P1]);
Zh [T0,T2];
Zh [p0,p2];
real[int] Tb(Zh.ndof);

macro Grad(u) [dx(u), dy(u)] //
macro Curl(u,v) (dx(v)-dy(u)) //
macro CurlS(u) [dy(u),-dx(u)] //

// sigma"
// do we need boundary conditions?
varf vZm([A0x,A0y,A2x,A2y],[a0x,a0y,a2x,a2y])
    =int2d(Th)( sig * [A0x,A0y]' * [a0x,a0y]
               +1/12 * sigLam * Curl(A0x,A0y) * Curl(a0x,a0y)
               -1/60 * sigLam * Curl(A0x,A0y) * Curl(a2x,a2y)
               -1/60 * sigLam * Curl(A2x,A2y) * Curl(a0x,a0y)
               +1/210* sigLam * Curl(A2x,A2y) * Curl(a2x,a2y));
matrix Zm = vZm(Xh,Xh,tgv=tgv,solver=CG);

// T calculations
varf vTm([T0,T2],[t0,t2])
    =int2d(Th)( CurlS(T0)'*CurlS(t0) + CurlS(T2)'*CurlS(t2) )
    +on(AirOutRight,AirOutTop,T0=0,T2=0);
varf vTb([T0,T2],[t0,t2])
    =int2d(Th)( sig * [E0sx,E0sy]'*CurlS(t0) 
               +1/12 * sigLam * [E0sx,E0sy]'*CurlS(t0)
               -1/60 * sigLam * [E0sx,E0sy]'*CurlS(t2)
               -1/60 * sigLam * [E2sx,E2sy]'*CurlS(t0)
               +1/210* sigLam * [E2sx,E2sy]'*CurlS(t2) )
    +on(AirOutRight,AirOutTop,T0=0,T2=0);
matrix Tm = vTm(Zh,Zh,tgv=tgv,solver=CG);

// K"
varf vKm([A0x,A0y,A2x,A2y],[a0x,a0y,a2x,a2y])
    =int2d(Th)(nu * Curl(A0x,A0y)' * Curl(a0x,a0y) + 0.2*yo*nu * Curl(A2x,A2y)' * Curl(a2x,a2y))
    +on(CoilTerminalIn,CoilTerminalOut, A0x=0,A0y=0,A2x=0,A2y=0)
    +on(AirInBot,AirOutBot,AirInLeft,AirOutLeft, A0x=0,A0y=0,A2x=0,A2y=0)
    +on(LaminLeft,LaminBot, A0x=0,A0y=0,A2x=0,A2y=0);
varf vKb([A0x,A0y,A2x,A2y],[a0x,a0y,a2x,a2y])
    =int2d(Th)(RR * Curl(a0x,a0y)*T0 + RR * Curl(a2x,a2y)*T2)
    +on(CoilTerminalIn,CoilTerminalOut, A0x=0,A0y=0,A2x=0,A2y=0)
    +on(AirInBot,AirOutBot,AirInLeft,AirOutLeft, A0x=0,A0y=0,A2x=0,A2y=0)
    +on(LaminLeft,LaminBot, A0x=0,A0y=0,A2x=0,A2y=0); //int2d(Th)(RR * Curl(a0x,a0y)*T0 + RR * Curl(a2x,a2y)*T2)
matrix Km = vKm(Xh,Xh,tgv=tgv,solver=CG);

// E
varf vEm([p0,p2],[pp0,pp2])
    =int2d(Th) ( sig*Grad(p0)'*Grad(pp0) + sigLam*Grad(p2)'*Grad(pp2) )
    +on(CoilTerminalIn,CoilTerminalOut, p0=0, p2=0)
    +on(LaminLeft,LaminBot, p0=0, p2=0);
varf vEb([p0,p2],[pp0,pp2])
    =int2d(Th)( 1./LL * ( sig*[A0sx,A0sy]'*Grad(pp0) + sigLam*[A2sx,A2sy]'*Grad(pp2) ) )
    +on(CoilTerminalIn,CoilTerminalOut, p0=0, p2=0)
    +on(LaminLeft,LaminBot, p0=0, p2=0);
matrix Em = vEm(Zh,Zh,tgv=tgv,solver=CG);

//step 1-1
solve Poisson(u,v,solver=CG)
	=int2d(Th) ( 4e7*co * Grad(u)' * Grad(v))
	+on(CoilTerminalIn, u=0)
	+on(CoilTerminalOut, u=1);

//step 1-2
[E0x[0],E0y[0],E2x[0],E2y[0]] = [dx(u),dy(u),0,0];
[J0x[0],J0y[0],J2x[0],J2y[0]] = [sig*E0x[0],sig*E0y[0],sigLam*E2x[0],sigLam*E2y[0]];
//step 2-1
Fm=Zm*E0x[0][];
//J0x[0][]=Zm*E0x[0][];
//step 2-2
lambda[0] = 1./(E0x[0][]'*Fm);
cout << "R0 = " << lambda[0] << endl;
//step 3-1
E0sx[]=E0x[0][];
Tb = vTb(0 ,Zh,tgv=tgv);
T0[] = Tm^-1*Tb;

//step 3-2
RR = lambda[0];
Fm = vKb(0,Xh,tgv=tgv);
A0x[0][] = Km^-1*Fm;
// step 3-3
Fm = Km*A0x[0][];
lambda[1] = A0x[0][]'*Fm;
cout << "L1 = " << lambda[1] << endl;
//step 4-1
LL=lambda[1];
A0sx[]=A0x[0][];
Tb = vEb(0,Zh,tgv=tgv);
p0[] = Em^-1*Tb;
//step 4-2
//E0x[1][]=E0x[0][]-1./LL*(A0sx[])+[dx(p0),dy(p0),dx(p2),dy(p2)];
[E0x[1],E0y[1],E2x[1],E2y[1]]=[E0x[0],E0y[0],E2x[0],E2y[0]]-[A0x[0]/LL,A0y[0]/LL,A2x[0]/LL,A2y[0]/LL]+[dx(p0),dy(p0),dx(p2),dy(p2)];
[J0x[1],J0y[1],J2x[1],J2y[1]] = [sig*E0x[1],sig*E0y[1],sigLam*E2x[1],sigLam*E2y[1]];

//step 2-1
Fm=Zm*E0x[1][];
//step 2-2
lambda[1] = 1./(E0x[1][]'*Fm);
cout << "R2 = " << lambda[1] << endl;

gmshScalarPlot("T0",Th,T0);
gmshScalarPlot("T2",Th,T2);

gmshVectorPlot("A0",Th,A0x[0],A0y[0]);
gmshVectorPlot("A2",Th,A2x[0],A2y[0]);

gmshVectorPlot("J0",Th,J0x[0],J0y[0]);
gmshVectorPlot("J2",Th,J2x[0],J2y[0]);

gmshVectorPlot("E0",Th,E0x[1],E0y[1]);
gmshVectorPlot("E2",Th,E2x[1],E2y[1]);

gmshVectorPlot("J0",Th,J0x[1],J0y[1]);
gmshVectorPlot("J2",Th,J2x[1],J2y[1]);

Ph B = Curl(A0x[0],A0y[0]);
gmshScalarPlot("B",Th,p2);

/*
Eh [Esx,Esy];
Ph Tz,tz;
varf vRm(Tz,tz)
	=int2d(Th)( [dy(tz),-dx(tz)]' * [dy(Tz),-dx(Tz)])
	+on(AirOutTop,AirOutRight,Tz=0);
varf vBm(Tz,tz)
    =int2d(Th)( sig * [dy(tz),-dx(tz)]' * [Esx, Esy] )
	+on(AirOutTop,AirOutRight,Tz=0);



varf vKm([A0x,A0y,A2x,A2y],[a0x,a0y,a2x,a2y])
    =int2d(Th)(nu * Curl(A0x,A0y)' * Curl(a0x,a0y) + 0.2*nu * Curl(A2x,A2y)' * Curl(a2x,a2y))
    +on(CoilTerminalIn,CoilTerminalOut, A0x=0,A0y=0,A2x=0,A2y=0)
    +on(AirInBot,AirOutBot,AirInLeft,AirOutLeft, A0x=0,A0y=0,A2x=0,A2y=0)
    +on(LaminLeft,LaminBot, A0x=0,A0y=0,A2x=0,A2y=0);

Ph T0z,T2z;
varf vFm([A0x,A0y,A2x,A2y],[a0x,a0y,a2x,a2y])
    =int2d(Th)(RR * Curl(a0x,a0y) * T0z + RR * Curl(a2x,a2y) * T2z)
    +on(CoilTerminalIn,CoilTerminalOut, A0x=0,A0y=0,A2x=0,A2y=0)
    +on(AirInBot,AirOutBot,AirInLeft,AirOutLeft, A0x=0,A0y=0,A2x=0,A2y=0)
    +on(LaminLeft,LaminBot, A0x=0,A0y=0,A2x=0,A2y=0);

matrix Km = vKm(Xh,Xh,tgv=tgv,solver=CG);
matrix Sm = vSm(Xh,Xh,tgv=tgv,solver=CG);
real[int] Fm(Xh.ndof);

matrix Rm = vRm(Ph,Ph,tgv=tgv,solver=CG);
[Esx,Esy] = [E0x[0],E0y[0]];
lambda[0] = 1./int2d(Th)(sig * [E0x[0],E0y[0]]' * [E0x[0],E0y[0]]);

real[int] Bm = vBm(0,Ph,tgv=tgv);
T0z[] = Rm^-1*Bm;
RR = lambda[0];
Fm = vFm(0,Xh,tgv=tgv);
A0x[0][] = Km^-1*Fm;

Xh [B0x,B0y,B2x,B2y]; B0x[]=Km*A0x[0][];
real chi; chi=A0x[0][]'*Fm;
cout << "R0  " << lambda[0] << endl;
cout << "chi " << chi << endl;
cout << "mii " << int2d(Th)(nu*Curl(A0x[0],A0y[0])*Curl(A0x[0],A0y[0])) << endl;

gmshVectorPlot("A0",Th,A0x[0],A0y[0]);
gmshVectorPlot("A2",Th,A2x[0],A2y[0]);
*/