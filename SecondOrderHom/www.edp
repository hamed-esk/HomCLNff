load "Element_Mixte"
include "../HomogenizedGeometry.idp"
include "../PlotInGMSH.idp"

//plot(Th);

int coil=Th( (PosCoilIn+PosCoilOut)/2,PosCoilIn/4).region;
int lamin=Th( PosCoilIn/2,PosCoilIn/2).region;  
int airIn=Th( PosCoilIn-RadiusCoil/2,PosCoilIn-RadiusCoil/2).region;
int airOut=Th( 1.1*PosCoilOut,1.1*PosCoilOut).region;

int numStages = 5;
real [int] lambda(2*numStages+1);
real RR;
real LL;
real nu0=1e7/4/pi;
real nu1=1e4/4/pi;
real InsRatio = 0.9;
real tgv = 1e30;

func co = 1.0*(region==coil);
func yo = 1.0*(region==lamin);
func ar = 1.0*(region==airIn)+1.0*(region==airOut)+1.0*(region==coil);
func sig=4e7*co;
func sigLam=1e6*(10e-3)^2*yo;
func nu=nu0*ar + nu1/InsRatio*yo;

fespace Ph(Th,P2);
Ph u,v,T0,q0,dE0s;

fespace Eh(Th,RT1Ortho);
Eh[int] [A0x,A0y](numStages);
Eh[int] [E0x,E0y](numStages+1);
Eh[int] [J0x,J0y](numStages+1);
Eh [A0sx,A0sy];
Eh [E0sx,E0sy];
Eh [Jsx,Jsy];
Eh [cdE0sx,cdE0sy];
real[int] Fm(Eh.ndof);

real[int] Tb(Ph.ndof);

macro Grad(u) [dx(u), dy(u)] //
macro Curl(u,v) (dx(v)-dy(u)) //
macro CurlS(u) [dy(u),-dx(u)] //

// sigma"
varf vZm([A0x,A0y],[a0x,a0y])
    =int2d(Th)( sig * [A0x,A0y]' * [a0x,a0y] +1./12 * sigLam * Curl(A0x,A0y) * Curl(a0x,a0y) );
matrix Zm = vZm(Eh,Eh,tgv=tgv,solver=CG);

// T calculations
varf vTm(T0,t0)
    =int2d(Th)( CurlS(T0)'*CurlS(t0) )
    +on(AirOutRight,AirOutTop,T0=0);
varf vTb(T0,t0)
    =int2d(Th)( sig * [E0sx,E0sy]'*CurlS(t0) + sigLam/12*[cdE0sx,cdE0sy]'*CurlS(t0))
    +on(AirOutRight,AirOutTop,T0=0); //+ sigLam/12*[dxy(E0sy)-dyy(E0sx),-dxx(E0sy)+dxy(E0sx)]'*CurlS(t0)
varf vTb2(T0,t0)
    =int2d(Th)( [Jsx,Jsy]'*CurlS(t0))
    +on(AirOutRight,AirOutTop,T0=0);
matrix Tm = vTm(Ph,Ph,tgv=tgv,solver=CG);

// K"
varf vKm([A0x,A0y],[a0x,a0y])
    =int2d(Th)(nu * Curl(A0x,A0y)' * Curl(a0x,a0y))
    +on(CoilTerminalIn,CoilTerminalOut, A0x=0,A0y=0)
    +on(AirInBot,AirOutBot,AirInLeft,AirOutLeft, A0x=0,A0y=0)
    +on(LaminLeft,LaminBot, A0x=0,A0y=0);
varf vKb([A0x,A0y],[a0x,a0y])
    =int2d(Th)(RR * T0 * Curl(a0x,a0y) )
    +on(CoilTerminalIn,CoilTerminalOut, A0x=0,A0y=0)
    +on(AirInBot,AirOutBot,AirInLeft,AirOutLeft, A0x=0,A0y=0)
    +on(LaminLeft,LaminBot, A0x=0,A0y=0);
matrix Km = vKm(Eh,Eh,tgv=tgv,solver=CG);

// E
varf vEm(q0,qq0)
    =int2d(Th) ( (co)*Grad(q0)'*Grad(qq0) )
    +on(CoilTerminalIn,CoilTerminalOut, q0=0)
    +on(LaminLeft,LaminBot, q0=0);
varf vEb(q0,qq0)
    =int2d(Th)( (co)*[A0sx/LL,A0sy/LL]'*Grad(qq0) )
    +on(CoilTerminalIn,CoilTerminalOut, q0=0)
    +on(LaminLeft,LaminBot, q0=0);
matrix Em = vEm(Ph,Ph,tgv=tgv,solver=CG);

//step 1-1
solve Poisson(u,v,solver=CG)
	=int2d(Th) ( 4e7*co * Grad(u)' * Grad(v))
	+on(CoilTerminalIn, u=0)
	+on(CoilTerminalOut, u=1);

//step 1-2
[E0x[0],E0y[0]] = [dx(u),dy(u)];
//step 2-1
Fm=Zm*E0x[0][];
lambda[0] = 1./(E0x[0][]'*Fm);
cout << "R0 = " << lambda[0] << endl;
//step 2-2
J0x[0][]=Zm*E0x[0][];
Jsx[]=Zm*E0x[0][];
//step 3-1
E0sx[]=E0x[0][];
dE0s = Curl(E0sx,E0sy);
[cdE0sx,cdE0sy] = CurlS(dE0s);
Tb = vTb2(0 ,Ph,tgv=tgv);
T0[] = Tm^-1*Tb;

//step 3-2
RR = lambda[0];
Fm = vKb(0,Eh,tgv=tgv);
A0x[0][] = Km^-1*Fm;
// step 3-3
Fm = Km*A0x[0][];
lambda[1] = A0x[0][]'*Fm;
cout << "L1 = " << lambda[1] << endl;

//step 4-1
LL=lambda[1];
A0sx[]=A0x[0][];
Tb = vEb(0,Ph,tgv=tgv);
q0[] = Em^-1*Tb;
//step 4-2
[E0x[1],E0y[1]]=(co+yo)*([E0x[0],E0y[0]]-[A0x[0]/LL,A0y[0]/LL]+[dx(q0),dy(q0)]); //
//step 2-1
Fm=Zm*E0x[1][];
lambda[2] = 1./(E0x[1][]'*Fm);
//lambda[2] = 1./int2d(Th)( sig * [E0x[1],E0y[1]]' * [E0x[1],E0y[1]] + 1./12*sigLam * Curl(E0x[1],E0y[1]) * Curl(E0x[1],E0y[1]) );
cout << "R2 = " << lambda[2] << endl;

//step 2-2
J0x[1][]=Zm*E0x[1][];
//step 3-1
E0sx[]=E0x[1][];
[E0sx,E0sy] =(yo)*([E0x[0],E0y[0]]-[A0x[0]/LL,A0y[0]/LL]+[dx(q0),dy(q0)]);
dE0s = sigLam*Curl(E0sx,E0sy);
[cdE0sx,cdE0sy] = CurlS(dE0s);
/*
Tb = vTb(0 ,Ph,tgv=tgv);
T0[] = Tm^-1*Tb;
//step 3-2
RR = lambda[2];
Fm = vKb(0,Eh,tgv=tgv);
A0x[1][] = Km^-1*Fm;
A0x[1][] = A0x[0][] + A0x[1][];
// step 3-3
Fm = Km*A0x[1][];
lambda[3] = A0x[1][]'*Fm;
cout << "L3 = " << lambda[3] << endl;
*/

gmshVectorPlot("J0",Th,J0x[0],J0y[0]);
gmshVectorPlot("J2",Th,J0x[1],J0y[1]);
gmshVectorPlot("E0s",Th,E0sx,E0sy);
gmshScalarPlot("d2",Th,dE0s);
gmshVectorPlot("cd2",Th,cdE0sx,cdE0sy);
gmshScalarPlot("T0",Th,T0);
Eh [cT0x,cT0y] = CurlS(T0);
gmshVectorPlot("cT0",Th,cT0x,cT0y);
system("graph.pos");